#include<iostream>
#include<stdexcept>
#include<algorithm>
#include"board.cpp"

bool is_game_won(const board& gboard);
point player_move(board& gboard);
bool is_game_solvable(const board& gboard);
int inversions(int a, int b, const std::vector<int>& list);
void quit(const bool gameWon, int moves, const board& gboard);


int main() {
	try{
		//Check if winnable board should be gaurenteed
		std::cout<<"Would you like a board that is gaurenteed to be solveable? (y/n)"<<std::endl<<"Note: Boards are generated by a dice roll, choosing yes will reroll until a solvable board is generated, and may take some time."<<std::endl;
		
		char choice;
		std::cin>>choice;

		std::cout<<"Enter board size (4 for standard 15 tile puzzle): ";
		int board_size;
		std::cin>>board_size;

		while(board_size<=1) {
			std::cout<<"Invalid board size. Board size must be greater than 1. Please enter a new board size."<<std::endl;
			std::cin.clear(); //reset stream state
			std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); //clear buffer
			std::cin>>board_size;
		}
	
		board gameBoard(board_size);
		
		gameBoard.set_board_width(board_size);

		if(choice=='y') {
			while(!is_game_solvable(gameBoard)) {
				gameBoard.init();
			}
		}
		else {
			std::cout<<std::endl<<"This board is NOT gaurenteed to be solvable."<<std::endl;
		}
		
		
		bool gameWon=false;
		int moves=0;
		
		gameBoard.draw(); 

		while(!gameWon){ //could use inversions==0
			point pMove=player_move(gameBoard);
			if(pMove.x==-2 && pMove.y==-2) { //end loop
				break;
			}
			else {
				gameBoard.swap_tile(gameBoard.empty_tile(), pMove);
			}
			moves++;
			gameBoard.draw();
			gameWon=is_game_won(gameBoard);
		}	

		quit(gameWon, moves, gameBoard);

		return 0;

	}
	catch(std::exception& e) {
		std::cerr<<e.what()<<std::endl;
		return 1;
	}
	catch(...) {
		std::cerr<<"Unknown Exception Thrown"<<std::endl;
		return 2;
	}

	return 0;
}

void quit(bool gameWon, int moves, const board& gboard) {
	if(gameWon) {
		std::cout<<"Congradulations! You Won!"<<std::endl
				<<"Moves Used: "<<moves<<std::endl;
	}
	else {
		std::cout<<"Better luck next time!"<<std::endl
				<<"Moves Used: "<<moves<<std::endl;
		if(is_game_solvable(gboard)) {
			std::cout<<"That game was solvable"<<std::endl;
		}
		else {
			std::cout<<"That game was NOT solvable"<<std::endl;
		}
		
	}
}

int inversions(int a, int b, const std::vector<int>& list) {
	int inver=0;
	std::vector<int> sortedList=list;
	std::sort(sortedList.begin(), sortedList.end());
	for(int i=a+1; i<b; i++) {
		if(list[a]>list[i] && list[a]!=sortedList[sortedList.size()-1]) { //ignore blank tile
			inver++;
		}
	}
	return inver;
}

bool is_game_solvable(const board& gboard) { 
/*Rules for solvable board:
 * If the grid width is odd, then the number of inversions in a solvable situation is even.
 * If the grid width is even, and the blank is on an even row counting from the bottom (second-last, fourth-last etc), then the number of inversions in a solvable situation is odd.
 * If the grid width is even, and the blank is on an odd row counting from the bottom (last, third-last, fifth-last etc) then the number of inversions in a solvable situation is even.
 */

	std::vector<int> nums=gboard.tile_order();

	//calculate inversions
	
	int inver=0;
	for(size_t i=0; i<nums.size(); i++) {
		inver+=inversions(i, nums.size(), nums);
	}

	//grid width even?

	bool bWidthEven;
	if(gboard.board_width()%2!=0) {
		bWidthEven=false;
	}
	else {
		bWidthEven=true;
	}

	//row from bottom of blank on even?
	
	bool emptyOnEven;
	
	point blankTile=gboard.empty_tile();
	int rowsFromBot=gboard.board_width()-blankTile.y;
	if(rowsFromBot%2!=0) {
		emptyOnEven=false;
	}
	else {
		emptyOnEven=true;
	}

	if((!bWidthEven && inver%2==0) || (bWidthEven && emptyOnEven && inver%2!=0) || (bWidthEven && !emptyOnEven && inver%2==0)) {
		return true;
	}

	return false;

}

bool is_game_won(const board& gboard) {
	//checks if board is sorted and returns true if it is
	
	std::vector<int> solvedBoard=gboard.tile_order();
	std::sort(solvedBoard.begin(), solvedBoard.end());
	solvedBoard.erase(solvedBoard.begin() + solvedBoard.size()-1); //remove clear tile
	
	std::vector<int> currBoard=gboard.tile_order();
	for(size_t i=0; i<currBoard.size(); i++) {
		if(currBoard[i]==gboard.board_width()*gboard.board_width()) {
			currBoard.erase(currBoard.begin() + i);
		}
	}

	for(size_t i=0; i<currBoard.size(); i++) {
		if(!(currBoard[i]==solvedBoard[i])) {
			return false;
		}
	}
	return true;
}

point player_move(board& gboard) {

	point empTile=gboard.empty_tile();
	point up,down,left,right;

	up.x=-1;
	up.y=-1;
	down.x=-1;
	down.y=-1;
	left.x=-1;
	left.y=-1;
	right.x=-1;
	right.y=-1;

	//in middle of board

	up.x=empTile.x;
	up.y=empTile.y-1;

	down.x=empTile.x;
	down.y=empTile.y+1;

	left.x=empTile.x-1;
	left.y=empTile.y;

	right.x=empTile.x+1;
	right.y=empTile.y;

	//print legal move options
	
	std::cout<<"Choose a tile to move or q to quit"<<std::endl;
	std::cout<<"Tiles: ";
	if(gboard.valid_point(up)) {
		std::cout<<gboard.tile(up)<<" ";
	}
	if(gboard.valid_point(down)) {
		std::cout<<gboard.tile(down)<<" ";
	}
	if(gboard.valid_point(left)) {
		std::cout<<gboard.tile(left)<<" ";
	}
	if(gboard.valid_point(right)) {
		std::cout<<gboard.tile(right);
	}
	std::cout<<std::endl;

	//check if q was entered
	
	char c;
	std::cin>>c;
	if(c=='q') {
		point exit;
		exit.x=-2;
		exit.y=-2;
		return exit;
		
	}
	else{
		std::cin.putback(c);
	}

	int tile;
	point pTile;
	std::cin>>tile;
	bool valid=false;

	while(!valid) {
		if(gboard.valid_point(up)) {
			if(gboard.tile(up)==tile) {
				valid=true;
				pTile=up;
			}
		}
		if(gboard.valid_point(down)) {
			if(gboard.tile(down)==tile) {
				valid=true;
				pTile=down;
			}
		}
		if(gboard.valid_point(left)) {
			if(gboard.tile(left)==tile) {
				valid=true;
				pTile=left;
			}
		}
		if(gboard.valid_point(right)) {
			if(gboard.tile(right)==tile) {
				valid=true;
				pTile=right;
			}
		}
		if(valid==false) {
			std::cout<<"Please enter a valid tile."<<std::endl;
			//flush input buffer
			std::cin.clear(); //reset stream state
			std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); //gotten from stackoverflow, ignores till end of line
			std::cin>>tile;
		}
	}

	return pTile;
}
